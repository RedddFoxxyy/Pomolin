# .github/workflows/build.yml
# This workflow builds, packages, and creates a draft release for the application on Windows (x64),
# macOS (x64, arm64), and Linux (x64, arm64), including AppImage for Linux.

name: Build and Release Testing

on:
  push:
    branches: [ "test-workflow" ]

  workflow_dispatch:

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-22.04
            arch: "x64"
            runner: "ubuntu-22.04"
            gradle_task: "packageReleaseDeb"
            os_name: "linux"
          - os: ubuntu-22.04-arm
            arch: "arm64"
            runner: "ubuntu-22.04-arm"
            gradle_task: "packageReleaseDeb"
            os_name: "linux"
          - os: ubuntu-latest
            arch: "x64"
            runner: "ubuntu-latest"
            os_name: "rocky-linux-8"
          - os: ubuntu-24.04-arm
            arch: "arm64"
            runner: "ubuntu-24.04-arm"
            os_name: "rocky-linux-8"

          - os: macos-13
            arch: "x64"
            runner: "macos-13"
            gradle_task: "packageReleaseDmg packageReleasePkg"
            os_name: "macos"
          - os: macos-latest
            arch: "arm64"
            runner: "macos-15"
            gradle_task: "packageReleaseDmg packageReleasePkg"
            os_name: "macos"

          - os: windows-latest
            arch: "x64"
            runner: "windows-latest"
            gradle_task: "packageReleaseMsi packageReleaseExe"
            os_name: "windows"
          - os: windows-11-arm
            arch: "arm64"
            runner: "windows-11-arm"
            gradle_task: "packageReleaseMsi packageReleaseExe"
            os_name: "windows"

    runs-on: ${{ matrix.runner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Update and Install Dependencies for Ubuntu
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update

      - name: Install Dependencies for Ubuntu-18
        if: matrix.os_name == 'rocky-linux-8'
        run: |
          sudo apt-get install -y curl wget git gnupg ca-certificates libfuse2 curl unzip binutils file libglib2.0-0

      - name: Set up JDK 21 for Windows ARM
        if: matrix.os == 'windows-11-arm'
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '21'
          architecture: ${{ matrix.arch }}

      - name: Set up JDK 24 for other architectures
        if: ${{ matrix.os != 'windows-11-arm' && matrix.os_name != 'rocky-linux-8' }}
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '24'
          architecture: ${{ matrix.arch }}

      - name: Grant execute permission for gradlew
        if: runner.os != 'Windows'
        run: chmod +x ./gradlew

      - name: Build Jar with Gradle on Windows
        if: matrix.os_name == 'windows'
        shell: bash
        run: ./gradlew.bat -PosArch=${{ matrix.arch }} ${{ matrix.gradle_task }} packageReleaseUberJarForCurrentOS

      - name: Build Jar with Gradle on macOS
        if: matrix.os_name == 'macos'
        run: ./gradlew -PosArch=${{ matrix.arch }} ${{ matrix.gradle_task }} packageReleaseUberJarForCurrentOS

      - name: Build Jar with Gradle on Ubuntu-24
        if: matrix.os_name == 'linux'
        run: ./gradlew -PosArch=${{ matrix.arch }} ${{ matrix.gradle_task }} packageReleaseUberJarForCurrentOS

      - name: Build AppImage on Rocky Linux 8
        if: matrix.os_name == 'rocky-linux-8'
        shell: bash
        run: |
          docker run --rm \
            -v ${{ github.workspace }}:${{ github.workspace }} \
            -w ${{ github.workspace }} \
            -e ARCH=${{ matrix.arch }} \
            rockylinux:8 /bin/bash -c '
              # 0. Install dependencies inside the container
              echo "Updating container and installing dependencies..."
              dnf update -y
              dnf install -y curl wget git ca-certificates fuse-libs unzip binutils file glib2 findutils
              echo "Adding Azul Zulu repository..."
              rpm --import https://repos.azul.com/azul-repo.key
              curl -s https://repos.azul.com/zulu/zulu-rhel.repo -o /etc/yum.repos.d/zulu.repo
          
              # Install Java 24 using manual download
              echo "Installing Java 24..."
              mkdir -p /usr/lib/jvm
              cd /tmp
              if [ "${{ matrix.arch }}" = "arm64" ]; then
                wget https://cdn.azul.com/zulu/bin/zulu24.32.13-ca-jdk24.0.2-linux_aarch64.tar.gz
                tar -xzf zulu24.32.13-ca-jdk24.0.2-linux_aarch64.tar.gz
                mkdir -p /usr/lib/jvm/zulu24
                mv zulu24.32.13-ca-jdk24.0.2-linux_aarch64/* /usr/lib/jvm/zulu24/
              else
                wget https://cdn.azul.com/zulu/bin/zulu24.32.13-ca-jdk24.0.2-linux_x64.tar.gz
                tar -xzf zulu24.32.13-ca-jdk24.0.2-linux_x64.tar.gz
                mkdir -p /usr/lib/jvm/zulu24
                mv zulu24.32.13-ca-jdk24.0.2-linux_x64/* /usr/lib/jvm/zulu24/
              fi
          
              echo "Setting JAVA_HOME and PATH..."
              export JAVA_HOME=/usr/lib/jvm/zulu24
              export PATH="$JAVA_HOME/bin:$PATH"
              java -version
          
              echo "Checking gradlew file..."
              cd ${{ github.workspace }}
              echo "Current directory: $(pwd)"
              ls -la ./gradlew
              chmod +x ./gradlew
          
              echo "Running Gradle createReleaseDistributable..."
              ./gradlew createReleaseDistributable
          
              # 1. Define paths and variables
              ARTIFACT_DIR="composeApp/build/compose/binaries/main-release"
              APP_NAME="pomolin"
              APPDIR_NAME="$APP_NAME.AppDir"
              GRADLE_APP_DIR="$ARTIFACT_DIR/app"
              SOURCE_POMOLIN_DIR="$GRADLE_APP_DIR/pomolin"
          
              # 1a. Create tar.gz archive for the Linux distributable
              echo "Creating tar.gz archive for the Linux distributable..."
              if [ -d "$SOURCE_POMOLIN_DIR" ]; then
                TAR_OUTPUT_DIR="$ARTIFACT_DIR/tarball"
                mkdir -p "$TAR_OUTPUT_DIR"
                TAR_FILENAME="pomolin_${{ matrix.arch }}_linux.tar.gz"
          
                echo "Archiving '$SOURCE_POMOLIN_DIR' to '$TAR_OUTPUT_DIR/$TAR_FILENAME'"
                # Use -C to change directory so the archive doesn''t contain the parent path
                tar -czf "$TAR_OUTPUT_DIR/$TAR_FILENAME" -C "$GRADLE_APP_DIR" "pomolin"
                echo "tar.gz archive created successfully."
              else
                echo "Error: The expected directory $SOURCE_POMOLIN_DIR was not found after gradle build."
                exit 1
              fi
          
              # 2. Dynamically select and download the correct appimagetool
              if [ "${{ matrix.arch }}" = "arm64" ]; then
                TOOL_ARCH="aarch64"
              else
                TOOL_ARCH="x86_64"
              fi
          
              TOOL_FILENAME="appimagetool-${TOOL_ARCH}.AppImage"
              TOOL_URL="https://github.com/AppImage/AppImageKit/releases/download/continuous/${TOOL_FILENAME}"
          
              echo "Downloading $TOOL_FILENAME..."
              wget -q "$TOOL_URL"
              chmod +x "$TOOL_FILENAME"
              ./"$TOOL_FILENAME" --appimage-extract && mv squashfs-root /usr/local/bin/appimagetool
          
              # 3. Create the AppDir structure
              echo "Creating $APPDIR_NAME..."
              mkdir -p "$APPDIR_NAME/usr/lib"
              echo "Moving $GRADLE_APP_DIR to $APPDIR_NAME/usr/lib/"
          
              # The app directory contains pomolin subdirectory, so we need to move the contents correctly
              if [ -d "$GRADLE_APP_DIR/pomolin" ]; then
                echo "Found pomolin subdirectory, moving it correctly..."
                mv "$GRADLE_APP_DIR/pomolin" "$APPDIR_NAME/usr/lib/$APP_NAME"
              else
                echo "Moving entire app directory as pomolin..."
                mv "$GRADLE_APP_DIR" "$APPDIR_NAME/usr/lib/$APP_NAME"
              fi
          
              echo "Checking final structure:"
              ls -la "$APPDIR_NAME/usr/lib/$APP_NAME/"
          
              # 4. Create the .desktop file
              echo "Creating .desktop file..."
              {
                echo "[Desktop Entry]"
              echo "Name=pomolin"
                echo "Comment=A simple Pomodoro App written in Kotlin. Focus on what matters!"
                echo "Exec=pomolin"
                echo "Icon=pomolin"
                echo "Terminal=false"
                echo "Type=Application"
                echo "Categories=Utility"
              } > "$APPDIR_NAME/$APP_NAME.desktop"
          
              # 5. Copy the icon
              echo "Copying icon..."
              ICON_STD_PATH="$APPDIR_NAME/usr/share/icons/hicolor/512x512/apps"
              mkdir -p "$ICON_STD_PATH"
              ICON_PATH="$APPDIR_NAME/usr/lib/$APP_NAME/lib/pomolin.png"
              if [ -f "$ICON_PATH" ]; then
                echo "Found icon at: $ICON_PATH"
                cp "$ICON_PATH" "$ICON_STD_PATH/$APP_NAME.png"
                cp "$ICON_PATH" "$APPDIR_NAME/$APP_NAME.png"
                else
                echo "Icon not found at expected location: $ICON_PATH"
                echo "Available files in lib directory:"
                ls -la "$APPDIR_NAME/usr/lib/$APP_NAME/lib/"
                exit 1
              fi
          
              # 6. Create the AppRun script
              echo "Creating AppRun script..."
              {
                echo "#!/bin/sh"
                echo "exec \"\$APPDIR/usr/lib/pomolin/bin/pomolin\" \"\$@\""
              } > "$APPDIR_NAME/AppRun"
              chmod +x "$APPDIR_NAME/AppRun"
          
              if [ ! -f "$APPDIR_NAME/AppRun" ]; then
                echo "ERROR: AppRun script was not created!"
                exit 1
              fi
          
              echo "Contents of $APPDIR_NAME:"
              ls -la "$APPDIR_NAME/"
              echo "About to run appimagetool..."
          
              # 7. Run the correct appimagetool
              echo "Building AppImage with appimagetool..."
              echo "Checking appimagetool installation:"
              ls -la /usr/local/bin/appimagetool/
          
              # Use the correct appimagetool path
              /usr/local/bin/appimagetool/AppRun "$APPDIR_NAME"
          
              # 8. Move the final AppImage to the artifacts directory for upload
              mkdir -p "$ARTIFACT_DIR/appimage"
              mv pomolin-*.AppImage "$ARTIFACT_DIR/appimage/"
              echo "AppImage created successfully!"
              '

      - name: Rename Packages for Release
        shell: bash
        run: |
          ARTIFACT_DIR="composeApp/build/compose/binaries/main-release"
          ARCH="${{ matrix.arch }}"

          rename_files() {
            DIR_PATH="$1"
            EXT="$2"
            if [ -d "$DIR_PATH" ]; then
              for f in "$DIR_PATH"/*."$EXT"; do
                if [ -f "$f" ]; then
                  # Constructs the new name, e.g., app-1.0.0.msi -> app-1.0.0-x64.msi
                  NEW_NAME="$(basename "$f" ."$EXT")-$ARCH.$EXT"
                  echo "Renaming $f to $DIR_PATH/$NEW_NAME"
                  mv "$f" "$DIR_PATH/$NEW_NAME"
                fi
              done
            fi
          }

          # Rename only the package types that have conflicting names
          rename_files "$ARTIFACT_DIR/dmg" "dmg"
          rename_files "$ARTIFACT_DIR/pkg" "pkg"
          rename_files "$ARTIFACT_DIR/msi" "msi"
          rename_files "$ARTIFACT_DIR/exe" "exe"

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: package-${{ matrix.os_name }}-${{ matrix.arch }}
          path: |
            composeApp/build/compose/binaries/main-release/deb/*.deb
            composeApp/build/compose/binaries/main-release/appimage/*.AppImage
            composeApp/build/compose/binaries/main-release/dmg/*.dmg
            composeApp/build/compose/binaries/main-release/pkg/*.pkg
            composeApp/build/compose/binaries/main-release/msi/*.msi
            composeApp/build/compose/binaries/main-release/exe/*.exe
            composeApp/build/compose/jars/*.jar
            composeApp/build/compose/binaries/main-release/tarball/*.tar.gz
          retention-days: 1

  release:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get Project Version
        id: get_version
        run: |
          # Extracts the version from the line 'packageVersion = "1.0.0"'
          VERSION=$(grep 'packageVersion = ' composeApp/build.gradle.kts | head -n 1 | sed -e 's/.*packageVersion = "\(.*\)"/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create Draft Release
        uses: softprops/action-gh-release@v2
        with:
          name: Pomolin v${{ steps.get_version.outputs.version }} Beta Test
          draft: true
          #          prerelease: false
          #          latest: false
          tag_name: v${{ steps.get_version.outputs.version }}-test
          body: |
            ### Description:

            Pomolin is a simple, beautiful, and minimalist Pomodoro timer for your desktop. Designed to help you stay focused and productive, it provides an elegant and straightforward way to manage your work and break intervals. With a clean interface and essential features, Pomolin helps you get into a rhythm of focused work sessions followed by refreshing breaks, all from a native desktop application.

            > Note: AppImages are the preferred way to run the app for linux, if you encounter any issues with AppImage, feel free to report them using github issues.

            ### 📦 Assets & Downloads:

            Download the appropriate package for your operating system and architecture below. All builds are created automatically via GitHub Actions. You can download an operating system specific package or an operating system specific jar.
            > Note: If using a jar to run the application, make sure that you are using Java 24. ( For windows 11 arm use Java21)

          files: artifacts/**/*